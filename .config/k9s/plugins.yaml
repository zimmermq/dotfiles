plugins:
  copy-yaml:
    shortCut: Ctrl-Y
    description: "copy yaml"
    scopes:
      - all
    command: zsh
    background: false
    args:
      - -c
      - |
        # Copy the YAML definition of a Kubernetes resource to clipboard
        set -euo pipefail
        
        echo "ðŸ“‹ Copying YAML for $RESOURCE_NAME/$NAME in namespace $NAMESPACE..."
        
        # Determine the clipboard command based on OS
        if command -v pbcopy &> /dev/null; then
          # macOS
          CLIPBOARD_CMD="pbcopy"
        elif command -v xclip &> /dev/null; then
          # Linux with xclip
          CLIPBOARD_CMD="xclip -selection clipboard"
        elif command -v xsel &> /dev/null; then
          # Linux with xsel
          CLIPBOARD_CMD="xsel --clipboard --input"
        elif command -v wl-copy &> /dev/null; then
          # Wayland
          CLIPBOARD_CMD="wl-copy"
        elif command -v clip.exe &> /dev/null; then
          # Windows
          CLIPBOARD_CMD="clip.exe"
        else
          echo "âŒ No clipboard command found (pbcopy, xclip, xsel, wl-copy, or clip.exe)"
          echo "YAML will be displayed but not copied"
          CLIPBOARD_CMD="cat"
        fi
        
        # Ensure we use the exact resource type from K9s
        resource_spec="$RESOURCE_NAME"
        if [[ "$RESOURCE_NAME" != *"."* ]] && [[ -n "$RESOURCE_GROUP" ]]; then
          # If RESOURCE_NAME is just the plural name, use the full specification
          resource_spec="${RESOURCE_NAME}.${RESOURCE_GROUP}"
        fi
        
        # Get the resource YAML definition and copy to clipboard
        if ! kubectl get "$resource_spec" -n "$NAMESPACE" "$NAME" -o yaml --context "$CONTEXT" | tee >(eval "$CLIPBOARD_CMD"); then
          echo "âŒ Failed to get resource YAML - check resource name and permissions"
          echo "Press enter to continue"
          read
          exit 1
        fi
        
        echo "âœ… YAML copied to clipboard successfully"
        echo "Press enter to continue"
        read
  exec-cluster:
    shortCut: Ctrl-X
    description: "connect to cluster"
    scopes:
      - kubernetesclusters
      - xkubernetesclusters
    command: zsh
    background: false
    args:
      - -c
      - |
        # Connect to a specific cluster and launch K9s with its configuration
        set -euo pipefail
        
        echo "ðŸ“¡ Connecting to cluster: $NAME..."
        if ! mscc k8s "$NAME"; then
          echo "âŒ Failed to connect to cluster"
          echo "Press enter to continue"
          read
          exit 1
        fi
        
        echo "âœ… Connection successful, launching K9s"
        k9s --kubeconfig /tmp/kubeconfig
  
  test-cluster:
    shortCut: Ctrl-T
    description: "test cluster"
    scopes:
      - kubernetesclusters
      - xkubernetesclusters
    command: zsh
    background: false
    args:
      - -c
      - |
        # Run test operations on the selected cluster
        set -euo pipefail
        
        echo "ðŸ§ª Testing cluster: $NAME..."
        if ! mscc k8s "$NAME" -t; then
          echo "âŒ Test failed"
        else
          echo "âœ… Test completed successfully"
        fi
        
        echo "Press enter to continue"
        read
  
  resource-trace:
    shortCut: Ctrl-B
    description: "beta trace"
    scopes:
      - all
    command: zsh
    background: false
    args:
      - -c
      - |
        # Trace dependencies for any Crossplane-managed resource
        set -euo pipefail
        
        echo "ðŸ” Analyzing resource: $NAME in namespace: $NAMESPACE"
        echo "ðŸ”§ Using resource type: $RESOURCE_NAME"
        echo "ðŸ”§ Resource group: $RESOURCE_GROUP"
        
        # Use the exact resource specification from K9s
        # RESOURCE_NAME should be the full CRD name (e.g., xtenants.pgsql.ms.infinity.cgm.ag)
        # RESOURCE_GROUP should be the API group (e.g., pgsql.ms.infinity.cgm.ag)
        
        # Get the kind from the resource using the exact RESOURCE_NAME
        if ! kind=$(kubectl get "$RESOURCE_NAME" -n "$NAMESPACE" "$NAME" -o=jsonpath='{.kind}' --context "$CONTEXT" 2>/dev/null); then
          echo "âŒ Failed to determine resource kind - is this a valid resource?"
          echo "Press enter to continue"
          read
          exit 1
        fi
        
        # Get the CRD to find the correct version
        crd_name="$RESOURCE_NAME"
        if [[ "$RESOURCE_NAME" != *"."* ]] && [[ -n "$RESOURCE_GROUP" ]]; then
          # If RESOURCE_NAME is just the plural name, construct the full CRD name
          crd_name="${RESOURCE_NAME}.${RESOURCE_GROUP}"
        fi
        
        echo "ðŸ”§ Looking up CRD: $crd_name"
        
        # Get the storage version from the CRD
        if ! version=$(kubectl get crd "$crd_name" -o=jsonpath='{.spec.versions[?(@.storage==true)].name}' --context "$CONTEXT" 2>/dev/null); then
          echo "âŒ Failed to get version from CRD $crd_name"
          # Fallback: try to get any version
          if ! version=$(kubectl get crd "$crd_name" -o=jsonpath='{.spec.versions[0].name}' --context "$CONTEXT" 2>/dev/null); then
            echo "âŒ Failed to determine version for CRD $crd_name"
            echo "Press enter to continue"
            read
            exit 1
          fi
        fi
        
        # Extract group from CRD name (everything after the first dot)
        if [[ "$crd_name" == *"."* ]]; then
          group="${crd_name#*.}"
          crossplane_format="$kind.$version.$group"
        else
          # Core resource
          crossplane_format="$kind.$version"
        fi
        
        echo "ðŸ“Š Resource: $crossplane_format - Running dependency trace"
        
        # Run crossplane trace with proper format
        if ! watch crossplane beta trace "$crossplane_format/$NAME" -n "$NAMESPACE"; then
          echo "âŒ Trace failed - is this a Crossplane-managed resource?"
        else
          echo "âœ… Trace completed"
        fi
        
        echo "Press enter to continue"
        read

  watch-events:
    shortCut: Shift-E
    description: "watch events"
    scopes:
      - all
    command: zsh
    background: false
    args:
      - -c
      - |
        # Stream Kubernetes events for the selected resource
        set -euo pipefail
        
        echo "ðŸ‘ï¸ Watching events for $RESOURCE_NAME/$NAME in namespace $NAMESPACE"
        echo "âŒ¨ï¸ Press Ctrl+C to exit"
        
        # Use kubectl events command with proper error handling
        if ! kubectl events --context "$CONTEXT" --namespace "$NAMESPACE" \
           --for "$RESOURCE_NAME.$RESOURCE_GROUP/$NAME" --watch; then
          echo "âŒ Failed to watch events - check resource name and permissions"
          echo "Press enter to continue"
          read
          exit 1
        fi

  argocd-sync:
    shortCut: s
    description: "sync ArgoCD Application"
    scopes:
      - application
    command: zsh
    background: true
    confirm: true
    args:
      - -c
      - |
        # Synchronize an ArgoCD application
        set -euo pipefail
        
        echo "ðŸ”„ Starting sync for ArgoCD application: $NAME in namespace: $NAMESPACE"
        
        if ! argocd app sync "$NAME" --app-namespace "$NAMESPACE"; then
          # We don't show this error since the command runs in background
          # but we'll log it to the background process
          echo "âŒ Sync failed for application: $NAME" >&2
          exit 1
        fi

  pg-status:
    shortCut: s
    description: "cnpg status"
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Display database cluster status
        set -euo pipefail
        echo "ðŸ“Š Retrieving status for $NAME in namespace $NAMESPACE"
        kubectl cnpg status "$NAME" -n "$NAMESPACE" --context "$CONTEXT" |& less -R

  pg-status-verbose:
    shortCut: Shift-S
    description: "cnpg status -v"
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Display detailed database cluster status
        set -euo pipefail
        echo "ðŸ” Retrieving detailed status for $NAME in namespace $NAMESPACE"
        kubectl cnpg status "$NAME" -n "$NAMESPACE" --context "$CONTEXT" --verbose |& less -R

  pg-logs:
    shortCut: l
    description: "cnpg logs"
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Stream logs from the database cluster
        set -euo pipefail
        echo "ðŸ“œ Streaming logs for $NAME in namespace $NAMESPACE"
        kubectl cnpg logs cluster "$NAME" -f -n "$NAMESPACE" --context "$CONTEXT"

  pg-shell:
    shortCut: p
    description: "cnpg psql"
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Open an interactive PSQL shell to the database
        set -euo pipefail
        echo "ðŸ˜ Opening PostgreSQL shell for $NAME in namespace $NAMESPACE"
        kubectl cnpg psql "$NAME" -n "$NAMESPACE" --context "$CONTEXT"

  # --- Database Maintenance Operations ---

  pg-backup:
    shortCut: b
    description: "cnpg backup"
    scopes:
      - cluster
    command: zsh
    confirm: true
    background: false
    args:
      - -c
      - |
        # Create a backup of the database cluster
        set -euo pipefail
        echo "ðŸ’¾ Creating backup for $NAME in namespace $NAMESPACE"
        kubectl cnpg backup "$NAME" -n "$NAMESPACE" --context "$CONTEXT" |& less -R

  pg-reload:
    shortCut: r
    description: "cnpg reload"
    confirm: true
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Reload database configuration without restart
        set -euo pipefail
        echo "ðŸ”„ Reloading configuration for $NAME in namespace $NAMESPACE"
        kubectl cnpg reload "$NAME" -n "$NAMESPACE" --context "$CONTEXT" |& less -R

  pg-restart:
    shortCut: Shift-R
    description: "cnpg restart"
    confirm: true
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Restart the database cluster
        set -euo pipefail
        echo "ðŸ”„ Restarting cluster $NAME in namespace $NAMESPACE"
        kubectl cnpg restart "$NAME" -n "$NAMESPACE" --context "$CONTEXT" |& less -R

  # --- Hibernation Controls ---

  pg-hibernate-status:
    shortCut: h
    description: "cnpg hibernate status"
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Check hibernate status of database cluster
        set -euo pipefail
        echo "ðŸ’¤ Checking hibernation status for $NAME in namespace $NAMESPACE"
        kubectl cnpg hibernate status "$NAME" -n "$NAMESPACE" --context "$CONTEXT" |& less -R

  pg-hibernate:
    shortCut: Shift-H
    description: "cnpg hibernate on"
    confirm: true
    scopes:
      - cluster
    command: zsh
    background: false
    args:
      - -c
      - |
        # Put database cluster into hibernation
        set -euo pipefail
        echo "ðŸ’¤ Hibernating cluster $NAME in namespace $NAMESPACE"
        kubectl cnpg hibernate on "$NAME" -n "$NAMESPACE" --context "$CONTEXT" |& less -R

  pg-hibernate-off:
    shortCut: Shift-W
    description: "cnpg hibernate off"
    confirm: true
    scopes:
      - namespace
    command: zsh
    background: false
    args:
      - -c
      - |
        # Wake up a hibernated database cluster
        set -euo pipefail
        echo "â° Waking up hibernated clusters in namespace $NAME"
        kubectl cnpg hibernate off "$NAME" -n "$NAME" --context "$CONTEXT" |& less -R

  download-kubeconfig:
    shortCut: Ctrl-J
    description: "download kubeConfig"
    scopes:
      - xkubernetesclusters
    command: zsh
    background: false
    args:
      - -c
      - |
        # Download kubeConfig for xkubernetesclusters resource
        set -euo pipefail
        
        echo "ðŸ“¥ Downloading kubeConfig for: $NAME"
        
        # Ensure the directory exists
        mkdir -p ~/.kube/config.d/
        
        # Set the path using just the resource name
        CONFIG_PATH=~/.kube/config.d/${NAME}
        
        echo "ðŸ“ Saving to: $CONFIG_PATH"
        
        # Extract the kubeConfig, decode it, and save it directly to the final path
        if ! kubectl get xkubernetesclusters.k8s.ms.infinity.cgm.ag "$NAME" -o jsonpath='{.status.kubeConfig}' | base64 -d > "$CONFIG_PATH"; then
          echo "âŒ Failed to download kubeConfig"
          echo "Press enter to continue"
          read
          exit 1
        fi
        
        # Set appropriate permissions
        chmod 600 "$CONFIG_PATH"
        
        echo "âœ… KubeConfig downloaded successfully to: $CONFIG_PATH"
        echo "Press enter to continue"
        read

  image-pull-speed:
    shortCut: Shift-D
    description: "image pull speed"
    scopes:
      - pods
    command: zsh
    background: false
    args:
      - -c
      - |
        set -euo pipefail

        echo "ðŸ“¥ Checking image download speed for pod $NAME in namespace $NAMESPACE"

        NODE=$(kubectl get pod "$NAME" -n "$NAMESPACE" --context "$CONTEXT" -o jsonpath='{.spec.nodeName}')
        if [ -z "$NODE" ]; then
          echo "âŒ Failed to get node name for pod $NAME"
          echo "Press enter to continue"
          read
          exit 1
        fi

        echo "ðŸ–¥ï¸  Running on node: $NODE"
        echo ""

        kubectl run speed-check-$$ --rm -it --restart=Never --image=alpine --privileged \
          --context "$CONTEXT" \
          --overrides="{\"spec\":{\"nodeName\":\"$NODE\",\"hostPID\":true}}" -- \
          nsenter -t 1 -m -u -n -i -p -- sh -c '
            CTR="/snap/microk8s/current/bin/ctr --address /var/snap/microk8s/common/run/containerd.sock -n k8s.io"
            ACTIVE=$($CTR content active 2>/dev/null)
            S1=$(echo "$ACTIVE" | tail -1 | awk "{gsub(/MB/,\"\"); print \$2}")
            sleep 10
            ACTIVE2=$($CTR content active 2>/dev/null)
            S2=$(echo "$ACTIVE2" | tail -1 | awk "{gsub(/MB/,\"\"); print \$2}")

            echo "=== Active Downloads ==="
            if [ -z "$ACTIVE" ] || [ $(echo "$ACTIVE" | wc -l) -le 1 ]; then
              echo "No active downloads"
            else
              echo "$ACTIVE"
              echo ""
              if [ -z "$S2" ] || [ $(echo "$ACTIVE2" | wc -l) -le 1 ]; then
                echo "Download completed during measurement"
              else
                SPEED=$(echo "$S2 $S1" | awk "{printf \"%.1f\", (\$1-\$2)/10*1024}")
                echo "Download Speed: ${SPEED} KB/s"
              fi
            fi
          '

        echo ""
        echo "Press enter to continue"
        read